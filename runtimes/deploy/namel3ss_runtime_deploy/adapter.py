"""
Deploy runtime adapter for Namel3ss.

This module provides functions to generate deployment configurations
(Docker, Kubernetes, cloud platforms) from Namel3ss IR.

PHASE 2 STATUS: Temporary bridge - wraps existing deployment logic
PHASE 3 TODO: Move actual deployment generation code here
"""

from pathlib import Path
from typing import Optional, Dict, Any
from namel3ss.ir import BackendIR


def generate_docker(
    ir: BackendIR,
    output_dir: str,
    base_image: str = "python:3.11-slim",
    multi_stage: bool = True,
    **kwargs
) -> None:
    """
    Generate Docker configuration from BackendIR.
    
    Phase 2: Temporary implementation - creates basic Dockerfile.
    Phase 3: Will be fully implemented with comprehensive Docker support.
    
    Args:
        ir: Backend intermediate representation
        output_dir: Directory to write Docker files
        base_image: Base Docker image to use
        multi_stage: Whether to use multi-stage build
        **kwargs: Additional configuration options
    """
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Phase 2: Create basic Dockerfile as proof of concept
    dockerfile_content = f"""# Generated by Namel3ss Deploy Runtime
# Base image
FROM {base_image}

# Set working directory
WORKDIR /app

# Copy requirements
COPY requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
    CMD python -c "import requests; requests.get('http://localhost:8000/health')"

# Run application
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
"""
    
    # Write Dockerfile
    dockerfile_path = output_path / "Dockerfile"
    dockerfile_path.write_text(dockerfile_content)
    
    # Create docker-compose.yml
    compose_content = f"""# Generated by Namel3ss Deploy Runtime
version: '3.8'

services:
  backend:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/{ir.app_name.lower()}
      - OPENAI_API_KEY=${{OPENAI_API_KEY}}
    depends_on:
      - db
    restart: unless-stopped

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB={ir.app_name.lower()}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

volumes:
  postgres_data:
"""
    
    compose_path = output_path / "docker-compose.yml"
    compose_path.write_text(compose_content)
    
    # Create .dockerignore
    dockerignore_content = """__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
.env
.venv
env/
venv/
ENV/
.git/
.gitignore
README.md
tests/
*.md
"""
    
    dockerignore_path = output_path / ".dockerignore"
    dockerignore_path.write_text(dockerignore_content)


def generate_kubernetes(
    ir: BackendIR,
    output_dir: str,
    namespace: str = "default",
    replicas: int = 3,
    **kwargs
) -> None:
    """
    Generate Kubernetes manifests from BackendIR.
    
    Phase 2: Placeholder - will be fully implemented in Phase 3.
    
    Args:
        ir: Backend intermediate representation
        output_dir: Directory to write K8s manifests
        namespace: Kubernetes namespace
        replicas: Number of replicas
        **kwargs: Additional configuration options
    """
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Phase 2: Create basic deployment.yaml as proof of concept
    deployment_content = f"""# Generated by Namel3ss Deploy Runtime
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {ir.app_name.lower()}-backend
  namespace: {namespace}
spec:
  replicas: {replicas}
  selector:
    matchLabels:
      app: {ir.app_name.lower()}-backend
  template:
    metadata:
      labels:
        app: {ir.app_name.lower()}-backend
    spec:
      containers:
      - name: backend
        image: {ir.app_name.lower()}-backend:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: {ir.app_name.lower()}-secrets
              key: database-url
---
apiVersion: v1
kind: Service
metadata:
  name: {ir.app_name.lower()}-backend
  namespace: {namespace}
spec:
  selector:
    app: {ir.app_name.lower()}-backend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8000
  type: LoadBalancer
"""
    
    deployment_path = output_path / "deployment.yaml"
    deployment_path.write_text(deployment_content)


def generate_aws_config(
    ir: BackendIR,
    output_dir: str,
    deployment_type: str = "ecs",
    region: str = "us-east-1",
    **kwargs
) -> None:
    """
    Generate AWS deployment configuration from BackendIR.
    
    Phase 2: Placeholder - will be fully implemented in Phase 3.
    
    Args:
        ir: Backend intermediate representation
        output_dir: Directory to write AWS config files
        deployment_type: AWS deployment type (ecs, lambda, beanstalk)
        region: AWS region
        **kwargs: Additional configuration options
    """
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Phase 2: Create basic task-definition.json for ECS
    if deployment_type == "ecs":
        task_def_content = f"""{{
  "family": "{ir.app_name.lower()}-task",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "containerDefinitions": [
    {{
      "name": "{ir.app_name.lower()}-backend",
      "image": "{ir.app_name.lower()}-backend:latest",
      "portMappings": [
        {{
          "containerPort": 8000,
          "protocol": "tcp"
        }}
      ],
      "environment": [
        {{
          "name": "AWS_REGION",
          "value": "{region}"
        }}
      ],
      "logConfiguration": {{
        "logDriver": "awslogs",
        "options": {{
          "awslogs-group": "/ecs/{ir.app_name.lower()}",
          "awslogs-region": "{region}",
          "awslogs-stream-prefix": "backend"
        }}
      }}
    }}
  ]
}}
"""
        
        task_def_path = output_path / "task-definition.json"
        task_def_path.write_text(task_def_content)


def generate_gcp_config(
    ir: BackendIR,
    output_dir: str,
    deployment_type: str = "cloud-run",
    region: str = "us-central1",
    **kwargs
) -> None:
    """
    Generate GCP deployment configuration from BackendIR.
    
    Phase 2: Placeholder - will be fully implemented in Phase 3.
    """
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Phase 2: Placeholder file
    readme_path = output_path / "README.md"
    readme_path.write_text(f"# GCP Deployment for {ir.app_name}\n\nComing in Phase 3")


def generate_azure_config(
    ir: BackendIR,
    output_dir: str,
    deployment_type: str = "container-instances",
    region: str = "eastus",
    **kwargs
) -> None:
    """
    Generate Azure deployment configuration from BackendIR.
    
    Phase 2: Placeholder - will be fully implemented in Phase 3.
    """
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Phase 2: Placeholder file
    readme_path = output_path / "README.md"
    readme_path.write_text(f"# Azure Deployment for {ir.app_name}\n\nComing in Phase 3")
